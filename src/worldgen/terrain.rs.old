use avian3d::prelude::*;
use bevy::asset::RenderAssetUsages;
use bevy::ecs::system::SystemState;
use bevy::pbr::{ExtendedMaterial, OpaqueRendererMethod};
use bevy::prelude::*;
use bevy::render::mesh::{Indices, PrimitiveTopology, VertexAttributeValues};
use bevy::render::view::NoFrustumCulling;
use bevy::utils::HashSet;
use fast_surface_nets::ndshape::{ConstShape, ConstShape3u32};
use fast_surface_nets::{surface_nets, SurfaceNetsBuffer};
use rayon::iter::{IntoParallelIterator, ParallelIterator};

use crate::materials::{CaveMaterialExtension, ATTRIBUTE_VOXEL_RATIO, ATTRIBUTE_VOXEL_TYPE};
use crate::physics::GameLayer;

use super::brush::collider::ColliderBrush;
use super::brush::{bounding_box_chunks, curve::*, Sampler};
use super::brush::{BoundingBoxChunks, VoxelSample};
use super::{consts::*, layout, VoxelMaterial};

type ChunkShape =
    ConstShape3u32<{ CHUNK_SAMPLE_SIZE + 2 }, { CHUNK_SAMPLE_SIZE + 2 }, { CHUNK_SAMPLE_SIZE + 2 }>;

const CHUNK_BORDER_INSET: f32 = 0.0;

#[derive(Component)]
pub struct Chunk;

#[derive(Component)]
pub struct ChunkData {
    chunk_pos: IVec3,
    world_pos: Vec3,
    materials: [VoxelMaterial; ChunkShape::USIZE],
    sdf: [f32; ChunkShape::USIZE],
    changes: [f32; ChunkShape::USIZE],
}

impl ChunkData {
    fn new(chunk_pos: IVec3) -> Self {
        let world_pos = chunk_pos.as_vec3() * CHUNK_SIZE as f32;

        Self {
            chunk_pos,
            world_pos,
            materials: [VoxelMaterial::Unset; ChunkShape::USIZE],
            sdf: [f32::MAX; ChunkShape::USIZE],
            changes: [0.0; ChunkShape::USIZE],
        }
    }
}

#[derive(Event)]
pub struct DestroyTerrain {
    pub position: Vec3,
    pub radius: f32,
    pub force: f32,
}

impl DestroyTerrain {
    fn world_extents(&self) -> (Vec3, Vec3) {
        let radius = Vec3::splat(self.radius);
        let min = self.position - radius;
        let max = self.position + radius;

        (min, max)
    }
}

struct SpawnChunk(ChunkData);

impl Command for SpawnChunk {
    fn apply(mut self, world: &mut World) {
        let mut system_state: SystemState<(
            Commands,
            ResMut<Assets<Mesh>>,
            ResMut<Assets<ExtendedMaterial<StandardMaterial, CaveMaterialExtension>>>,
            Query<(&CurveBrush, &BoundingBoxChunks)>,
            Query<(&ColliderBrush, &BoundingBoxChunks)>,
        )> = SystemState::new(world);

        let (mut commands, mut meshes, mut materials, curve_brush_query, collider_brush_query) =
            system_state.get_mut(world);

        let world_pos = self.0.world_pos;

        // Sample curve brushes
        for (brush, bbox) in curve_brush_query.iter() {
            // if bbox.chunks.contains(&self.0.chunk_pos) {
            merge_chunk(&mut self.0, || {
                chunk_samples(&world_pos)
                    .map(|point| brush.sample(point))
                    .collect()
            });
            //  }
        }

        // Sample mesh brushes
        for (brush, bbox) in collider_brush_query.iter() {
            //  if bbox.chunks.contains(&self.0.chunk_pos) {
            merge_chunk(&mut self.0, || {
                chunk_samples(&world_pos)
                    .map(|point| brush.sample(point))
                    .collect()
            });
            //    }
        }

        if let Some((mesh, collider)) = mesh_chunk(&self.0) {
            let translation = self.0.chunk_pos.as_vec3() * CHUNK_SIZE as f32;
            let scale = Vec3::splat(1.0 / CHUNK_SAMPLE_RESOLUTION);

            commands.spawn((
                NoFrustumCulling, // TODO remove this
                Chunk,
                self.0,
                collider,
                Transform::from_translation(translation).with_scale(scale),
                RigidBody::Static,
                CollisionLayers::new(GameLayer::World, LayerMask::ALL),
                DebugRender::default().without_collider().without_axes(),
                Mesh3d(meshes.add(mesh)),
                MeshMaterial3d(materials.add(ExtendedMaterial {
                    base: StandardMaterial {
                        base_color: Color::srgb(0.5, 0.5, 0.5),
                        opaque_render_method: OpaqueRendererMethod::Auto,
                        ..Default::default()
                    },
                    extension: CaveMaterialExtension {
                        render_voxel_size: 7.0,
                        voxel_type_transition_steps: 5.0,
                    },
                })),
            ));

            system_state.apply(world);
        }
    }
}

pub struct TerrainPlugin;

impl Plugin for TerrainPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<DestroyTerrain>()
            .add_systems(Startup, (setup, layout::setup_debug_layout.before(setup)))
            .add_systems(Update, (draw_debug, destroy_terrain));
    }
}

fn setup(
    mut commands: Commands,
    bbox_query: Query<&BoundingBoxChunks>,
    curve_brush_query: Query<(&CurveBrush, &BoundingBoxChunks)>,
    collider_brush_query: Query<(&ColliderBrush, &BoundingBoxChunks)>,
) {
    let mut chunks = HashSet::<IVec3>::new();

    for bbox in bbox_query.iter() {
        chunks.extend(&bbox.chunks);
    }

    for chunk_pos in chunks {
        let data = ChunkData::new(chunk_pos);
        commands.queue(SpawnChunk(data));
    }
}

fn destroy_terrain(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut event: EventReader<DestroyTerrain>,
    mut chunk_query: Query<(Entity, &mut ChunkData)>,
) {
    let events: Vec<(&DestroyTerrain, BoundingBoxChunks)> = event
        .read()
        .map(|e| (e, bounding_box_chunks(e.world_extents(), 0)))
        .collect();
    if events.len() == 0 {
        return;
    }

    let mut chunks_to_generate: HashSet<IVec3> =
        events.iter().flat_map(|e| e.1.chunks.clone()).collect();

    // meshes aren't aligning and are green because they don't have distances/materials from the
    // other brushes. the boundingboxchunks optimization probably needs to be removed.

    chunk_query.iter_mut().for_each(|(entity, mut data)| {
        let mut changed = false;

        chunks_to_generate.remove(&data.chunk_pos);

        for (e, bbox_chunks) in events.iter() {
            // if !bbox_chunks.chunks.contains(&data.chunk_pos) {
            //     continue;
            // }

            let world_pos = data.world_pos.clone();
            changed = changed
                || merge_sdf(&mut data.sdf, || {
                    chunk_samples(&world_pos)
                        .map(|point| e.position.distance(point) - e.radius)
                        .collect()
                });
        }

        if changed {
            if let Some((mesh, collider)) = mesh_chunk(&data) {
                let mut commands = commands.entity(entity);
                commands.remove::<Collider>();
                commands.insert(collider);
                commands.remove::<Mesh3d>();
                commands.insert(Mesh3d(meshes.add(mesh)));
            } else {
                commands.entity(entity).clear();
            }
        }
    });

    for chunk_pos in chunks_to_generate {
        for (e, _) in events.iter() {
            let mut data = ChunkData::new(chunk_pos);
            let world_pos = data.world_pos.clone();

            merge_sdf(&mut data.sdf, || {
                chunk_samples(&world_pos)
                    .map(|point| e.position.distance(point) - e.radius)
                    .collect()
            });

            commands.queue(SpawnChunk(data));
        }
    }
}

fn draw_debug(mut gizmos: Gizmos, chunk_query: Query<&Transform, With<Chunk>>) {
    if CHUNK_RENDER_BORDERS {
        for transform in chunk_query.iter() {
            gizmos.cuboid(
                Transform::from_translation(
                    (*transform).translation
                        + Vec3::splat(CHUNK_SIZE as f32 / 2.0 + CHUNK_BORDER_INSET),
                )
                .with_scale(Vec3::splat(CHUNK_SIZE as f32 - CHUNK_BORDER_INSET * 2.0)),
                Color::srgba(0.0, 0.0, 0.0, 0.25),
            );
        }
    }

    gizmos.axes(
        Transform::from_translation(Vec3::splat(0.125)),
        CHUNK_SIZE as f32,
    );
}

//
// Utility
//

fn delinearize_to_world_pos(chunk_world_pos: Vec3, sample: u32) -> Vec3 {
    let [x, y, z] = ChunkShape::delinearize(sample);
    let point = Vec3::new(x as f32, y as f32, z as f32);
    point / CHUNK_SAMPLE_RESOLUTION + chunk_world_pos
}

fn chunk_samples(
    chunk_world_pos: &Vec3,
) -> rayon::iter::Map<rayon::range::Iter<u32>, impl Fn(u32) -> Vec3> {
    let chunk_world_pos = chunk_world_pos.clone();
    (0u32..ChunkShape::SIZE)
        .into_par_iter()
        .map(move |i| delinearize_to_world_pos(chunk_world_pos, i))
}

fn merge_sdf<F>(sdf: &mut [f32; ChunkShape::USIZE], sampler: F) -> bool
where
    F: Fn() -> Vec<f32>,
{
    let mut changed = false;
    let new_sdf = sampler();
    for (i, distance) in new_sdf.into_iter().enumerate() {
        if distance <= sdf[i] {
            sdf[i] = distance;
            changed = true;
        }
    }

    changed
}

fn merge_chunk<F>(data: &mut ChunkData, sampler: F)
where
    F: Fn() -> Vec<VoxelSample>,
{
    let new_sdf = sampler();
    for (i, sample) in new_sdf.into_iter().enumerate() {
        if sample.distance <= data.sdf[i] {
            data.sdf[i] = sample.distance;
            data.materials[i] = sample.material;
        } else if data.materials[i] == VoxelMaterial::Unset {
            data.materials[i] = sample.material;
        }
    }
}

fn mesh_chunk(data: &ChunkData) -> Option<(Mesh, Collider)> {
    let mut sdf = data.sdf.clone();

    if CHUNK_INTERNAL_GEOMETRY {
        for i in 0..ChunkShape::SIZE {
            sdf[i as usize] = -sdf[i as usize];
        }
    }

    let mut buffer = SurfaceNetsBuffer::default();
    surface_nets(
        &sdf,
        &ChunkShape {},
        [0; 3],
        [CHUNK_SAMPLE_SIZE + 1; 3],
        &mut buffer,
    );

    if buffer.positions.len() < 3 || buffer.indices.len() < 3 {
        return None;
    }

    let mut physics_mesh = Mesh::new(PrimitiveTopology::TriangleList, RenderAssetUsages::all());
    physics_mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, buffer.positions);
    physics_mesh.insert_indices(Indices::U32(buffer.indices));

    let collider = Collider::trimesh_from_mesh_with_config(
        &physics_mesh,
        TrimeshFlags::MERGE_DUPLICATE_VERTICES,
    )
    .unwrap();

    // Unconnected triangles are required to blend voxel types
    let mut render_mesh = physics_mesh.clone();
    render_mesh.duplicate_vertices();
    render_mesh.compute_flat_normals();

    let positions = render_mesh
        .attribute(Mesh::ATTRIBUTE_POSITION)
        .unwrap()
        .as_float3()
        .unwrap();
    let voxel_types: Vec<u8> = positions
        .iter()
        .map(|pos| {
            let index = ChunkShape::linearize([
                pos[0].floor() as u32,
                pos[1].floor() as u32,
                pos[2].floor() as u32,
            ]);
            data.materials[index as usize] as u8
        })
        .collect();
    let voxel_types: Vec<[u8; 4]> = (0..(positions.len() / 3))
        .flat_map(|i| {
            let a = voxel_types[i * 3];
            let b = voxel_types[i * 3 + 1];
            let c = voxel_types[i * 3 + 2];
            vec![[a, b, c, 0], [a, b, c, 0], [a, b, c, 0]]
        })
        .collect();
    let voxel_ratios: Vec<[f32; 3]> = (0..positions.len())
        .map(|i| match i % 3 {
            0 => [1.0, 0.0, 0.0],
            1 => [0.0, 1.0, 0.0],
            _ => [0.0, 0.0, 1.0],
        })
        .collect();

    render_mesh.insert_attribute(ATTRIBUTE_VOXEL_RATIO, voxel_ratios);
    render_mesh.insert_attribute(
        ATTRIBUTE_VOXEL_TYPE,
        VertexAttributeValues::Uint8x4(voxel_types),
    );

    Some((render_mesh, collider))
}
