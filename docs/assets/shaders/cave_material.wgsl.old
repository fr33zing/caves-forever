#import bevy_pbr::{
    pbr_types::PbrInput,
    pbr_fragment::pbr_input_from_standard_material,
    pbr_functions::alpha_discard,
}

#ifdef PREPASS_PIPELINE
#import bevy_pbr::{
    prepass_io::{VertexOutput, FragmentOutput},
    pbr_deferred_functions::deferred_output,
}
#else
#import bevy_pbr::{
    forward_io::{VertexOutput, FragmentOutput},
    pbr_functions::{apply_pbr_lighting, main_pass_post_lighting_processing},
}
#endif

#import noisy_bevy::simplex_noise_3d
#import noisy_bevy::simplex_noise_2d

//
// Data
//

struct CaveMaterial {
    quantize_steps: u32,
}

@group(2) @binding(100)
var<uniform> cave_material: CaveMaterial;

struct VoxelMaterial {
    base_color: vec3<f32>,
}

//
// Utility functions
//

fn quantize(v: f32, steps: f32) -> f32 {
    return round(v * steps) / steps;
}

fn quantize_3d(v: vec3<f32>, steps: f32) -> vec3<f32> {
    return round(v * steps) / steps;
}

fn clamp_scaled(v: f32, min: f32, max: f32) -> f32 {
    return v * (max - min) + min;
}

// Voxel functions

fn voxel_default(
    pos: vec3<f32>
) -> VoxelMaterial {
    var noise = 0.5;
    noise = mix(noise, simplex_noise_3d(pos.xyz / 2.0), 0.3);
    noise = mix(noise, simplex_noise_3d(pos.xyz / 4.0), 0.3);
    noise = mix(noise, simplex_noise_3d(pos.xyz / 8.0), 0.3);
    noise = clamp_scaled(noise, 0.35, 1.0);
    noise = quantize(noise, 7.0);

    const vertical_noise_scale = vec3(1.0 / 64.0, 1.0 / 6.0, 1.0 / 64.0);
    var vertical_noise = simplex_noise_3d(pos.xyz * vertical_noise_scale);
    vertical_noise = quantize(vertical_noise, 4.0);
    const color1 = vec3(0.32, 0.16, 0.08);
    const color2 = vec3(0.12, 0.00, 0.00);
    let color = mix(color1, color2, vertical_noise);

    let out_base_color = mix(vec3(0.0, 0.0, 0.0), color, noise);

    return VoxelMaterial(out_base_color);
}

//
// Entry points
//

@fragment
fn fragment(
    in: VertexOutput,
    @builtin(front_facing) is_front: bool,
) -> FragmentOutput {
    const scale: f32 = 1.0 / 8.0;
    const steps: f32 = 4.0;

    let quantized_pos = quantize_3d(in.world_position.xyz, steps);
    var voxel = voxel_default(quantized_pos);

    var pbr_input = pbr_input_from_standard_material(in, is_front);
    pbr_input.material.base_color = vec4(voxel.base_color, 1.0);
    pbr_input.material.perceptual_roughness = 1.0;
    pbr_input.material.reflectance = 0.0;

    pbr_input.material.base_color = alpha_discard(pbr_input.material, pbr_input.material.base_color);

#ifdef PREPASS_PIPELINE
    let out = deferred_output(in, pbr_input);
#else
    var out: FragmentOutput;

    out.color = apply_pbr_lighting(pbr_input);

    // (optional) modify the lit color before post-processing is applied here

    out.color = main_pass_post_lighting_processing(pbr_input, out.color);

    // (optional) modify the final result here
#endif

    return out;
}
